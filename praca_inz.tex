
\documentclass[a4paper]{article}

\usepackage[polish]{babel}
\usepackage{lmodern} %Type1-font for non-english texts and characters
\usepackage{amsmath}%
\usepackage{amsfonts}%
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{polski}
\usepackage[cp1250]{inputenc}
\usepackage{svg}
\usepackage{float}
\usepackage{enumerate}
\usepackage{indentfirst}
\usepackage{url}
\usepackage{listings}


\definecolor{darkred}{rgb}{0.9,0,0}
\definecolor{grey}{rgb}{0.4,0.4,0.4}
\definecolor{orange}{rgb}{1,0.6,0.05}
\definecolor{darkgreen}{rgb}{0.2,0.5,0.05}


%-------------------------------------------


\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-5cm}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-5cm}
\setlength{\oddsidemargin}{0cm}
\setlength{\evensidemargin}{0cm}
\topmargin -1.25cm
\footskip 1.4cm
\graphicspath{ {./fig/} }
%\lstset{language=C++, commentstyle=\color{blue},breaklines=true, basicstyle=\small, }
\lstset{language=C++,
basicstyle=\sffamily\scriptsize,
keywordstyle=\color{darkgreen}\sffamily\bfseries\scriptsize,
stringstyle=\color{darkgreen}\sffamily\scriptsize,
commentstyle=\color{grey}\sffamily\scriptsize,
numbers=left,
breaklines=true,
numberstyle=\color{grey}\sffamily\scriptsize,
identifierstyle=\color{blue}\sffamily\scriptsize,
showstringspaces=false,
morekeywords={
}}

\title{POLITECHNIKA POZNAÑSKA
\vspace{0.2cm}

\Large WYDZIA£ AUTOMATYKI, ROBOTYKI I ELEKTROTECHNIKI

INSTYTUT ROBOTYKI I INTELIGENCJI MASZYNOWEJ

ZAK£AD STEROWANIA I ELEKTRONIKI PRZEMYS£OWEJ
\vspace{1cm}
\begin{figure}[H]
\centering
\includegraphics{logo.png}   
\end{figure} 
\vspace{1cm}
PRACA DYPLOMOWA 

IN¯YNIERSKA
\vspace{1cm}

\large MIKROPROCESOROWY KASKADOWY UK£AD REGULACJI PR¥DU, PRÊDKOŒCI I PO£O¯ENIA DLA NAPÊDU Z 
SILNIKIEM BLDC

\vspace{2cm}
\begin{flushleft}
\normalsize

\hspace{8cm}PROMOTOR:

\hspace{8cm}DR IN¯. DOMINIK £UCZAK
\vspace{0.2cm}

\scriptsize \hspace{8cm}POTWIERDZAM PRZYJÊCIE PRACY:
\vspace{0.5cm}

\hspace{8cm}...........................


\scriptsize \hspace{8cm}DATA I PODPIS PROMOTORA
\end{flushleft}
\vspace{0.5cm}
}

\author{MATEUSZ SEMK£O}

\date{2020-11-30}



\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage


\section{Wstêp}

Tematem pracy in¿ynierskiej jest\textit{Mikroprocesorowy kaskadowy uk³ad regulacji pr¹du, prêdkoœci i po³o¿enia dla napêdu z silnikiem BLDC}. Zainteresowanie i zdobyta wiedza z zakresu automatyki, mikroprocesorów i maszyn elektrycznych  spowodowa³a chêæ stworzenia  uk³adu napêdowego dla silnika BLDC przy wykorzystaniu mo¿liwoœci mikrokontrolerów i stawieniu czo³a trudnoœciom przy jego praktycznej realizacji.  

Celem jest pokazanie mo¿liwoœci wykorzystania mikroprocesora z rodziny ARM Cortex wbudowanego w mikrokontroler firmy STM32 jako jednego ze sposobów na sprzêtow¹ realizacje uk³adu sterowania dla silnika BLDC. Zaimplementowanie Sterowania Zorientowanego Polowo (ang. Field Orient Cotrol) z kaskadow¹ konfiguracj¹ uk³adów regulacji pr¹du, prêdkoœci, po³o¿enia oraz wykorzystanie wektorowej modulacji szerokoœci impulsów SVPWM (ang. Space Vector Pulse Width Modulation).

 Zakres pracy obejmuje:
\begin{itemize}
\item{dobór i uruchomienie mikroprocesorowej p³yty rozwojowej STM32 dla wybranego uk³adu napêdowego z silnikiem BLDC,}
\item{dobór parametrów regulatorów PID. Wykorzystanie regulatorów dostêpnych w bibliotece CMSIS-DSP,}
\item{opracowanie interfejsu u¿ytkownika pozwalaj¹cego na parametryzacjê i monitoring pracy napêdu w czasie rzeczywistym,}
\item{analiza mo¿liwoœci wykonania procedury automatycznego strojenia uk³adu napêdowego.}
\end{itemize}


Silnik BLDC (ang. Burshless Direct Current) nale¿y do rodziny silników z magnesami trwa³ymi. Charakteryzuje siê sta³ym momentem elektromagnetycznym w szerokim zakresie prêdkoœci obrotowej. Brak komutatora zapewnia wiêksz¹ sprawnoœæ i ¿ywotnoœæ silnika. Z powodu wielu zalet czêsto wykorzystywane  w automatyce i robotyce.

Silnik  ze wzglêdu na konstrukcje wymaga bardziej z³o¿onego sposobu sterowania w porównaniu z silnikiem pr¹du sta³ego. W tym celu wykorzystana zosta³a metoda sterowania wektorowego FOC (ang. Field-orient control). Jest to jedna z powszechnie stosowanych technik w uk³adach regulacji trójfazowych silników synchronicznych z magnesami trwa³ymi. Pozwala ona sprowadziæ wartoœci pr¹dów fazowych stojana z trójwymiarowego uk³ad wspó³rzêdnych do wiruj¹cego uk³adu o dwóch wspó³rzêdnych biegn¹cego synchronicznie  z wektorem strumienia wirnika. Uzyskujemy w ten sposób dostêp do dwóch wartoœci sta³ych - pr¹du i strumienia magnetycznego, które mo¿na umieœciæ bezpoœrednio w pêtlach regulatorów PID i uzyskaæ mo¿liwoœæ regulacji pr¹dem, wzbudzeniem, prêdkoœci¹ i po³o¿eniem.

 Do modulacji szerokoœci impulsów wykorzystano metodê SVPWM (ang. Space Vector Pulse Width Modulation). W porównaniu z alternatywn¹ modulacj¹ SPWM (ang. Sine Pulse Width Modulation) cechujê siê mniejszymi zniekszta³ceniami sygna³u spowodowanych przez wy¿sze harmoniczne i wykorzystujê wiêkszy przedzia³ napiêcia zasilania. W wyniku modulacji SVPWM generowane s¹ wektory, które przyjmuj¹ kszta³t szeœciok¹ta i dziel¹ przestrzeñ na szeœæ sektorów. Wektor referencyjny jest generowany w wyniku aktywowania dwóch s¹siaduj¹cych wektorów z przestrzeni stanu w okreœlonej sekwencji i czasie. W wyniku tych operacji formowane s¹ trzy sygna³y PWM dla trzech par tranzystorów przekszta³tnika energoelektronicznego. 
 
G³ównymi elementami uk³adu jest zestaw prototypowy STM32 B-G431B-ESC1 oraz STM32 Nucleo F746ZG. B-G431B-ESC1 wyposa¿ony w mikrokontroler STM32G431CB, rdzeñ ARM Cortex M4, trójfazowy przekszta³tnik energoelektroniczny jest uk³adem realizuj¹cym proces regulacji pr¹du, prêdkoœci i po³o¿enia wirnika.  Nucleo F746ZG odpowiada za komunikacjê miêdzy regulatorem a interfejsem u¿ytkownika. Aplikacja u¿ytkownika jest napisana w jêzyku python i ³¹czy siê z p³yt¹ Nucleo F746ZG za poœrednictwem przewodu sieciowego przy wykorzystaniu protok³u TCP/IP. Informacje przekazywane s¹ w postaci ³añcuchów znaków w formacie JSON.  
Specyfika uk³adu pomiarowego pr¹du wymaga aby pomiar by³ wykonywany, gdy wszystkie tranzystory grupy górnej by³y wy³¹czone a grupy dolnej w³¹czone. Wyzwolenie nastêpuje w osi symetrii ka¿dego okresu sygna³u PWM.  W funkcji obs³ugi zdarzenia przeprowadzane s¹ wszystkie operacje zwi¹zane z regulacj¹ i modulacj¹ sygna³ów.

W uk³adzie zdefiniowane s¹ cztery regulatory PID: pr¹du, strumienia magnetycznego wirnika skojarzonego ze stojanem, prêdkoœci i po³o¿enia wirnika. S¹ one po³¹czone ze sob¹ w sposób kaskadowy. Pêtle regulacji s¹ zagnie¿d¿one jedna w drugiej, gdzie wyjœcie z regulatora pêtli zewnêtrznej ustala wartoœæ zadan¹ pêtli wewnêtrznej. 

Przy pomocy oscyloskopu i oprogramowania STMStudio do podgl¹du zmiennych programu w czasie rzeczywistym przeprowadzono pomiary pr¹du, prêdkoœci i po³o¿enia wirnika dla ró¿nych wartoœci zadanych przy okreœlonych nastawach regulatorów PID. Zmierzone przebiegi najistotniejszych wielkoœci zosta³y przedstawione w rozdziale \ref{chapter:3}.


     




\section{Silnik BLDC}
\subsection{Budowa}
Bezszczotkowe silniki z magnesami trwa³ymi mo¿na podzieliæ na silniki pr¹du sta³ego BLDC oraz synchroniczne silniki pr¹du przemiennego PMSM (ang. Permanent Magnet Synchronous Motor). Ró¿ni¹ siê one kszta³tem przebiegu si³y elektromotorycznej. Na rysunku \ref{fig:1} przedstawiono przebiegi indukowanego napiêcia, pr¹du i momentu elektromagnetycznego dla silnika BLDC i PMSM. \cite{goryca2012metody}

\begin{figure}[H]
\centering
\includegraphics[width=12cm]{przebieg_SEM.png} 
\caption{Przebiegi si³y elektromotorycznej E, pr¹du I i momentu T dla jednej fazy dla:
 a) silnika PMSM, b) silnika BLDC \cite{zajkowski2013sterowanie} }
\label{fig:1}
\end{figure} 

Istnieje wiele odmian silników BLDC ró¿ni¹cych siê budow¹, konstrukcj¹ obwodów magnetycznych, rozk³adem indukcji i kszta³tem si³ elektromotorycznych. Uzwojenie  twornika jest zazwyczaj w stojanie i jest uzwojeniem trójfazowym. Kszta³t magnesów trwa³e umieszczonych na wirniku zapewniaj¹ sta³¹ wartoœæ indukcji w szczelinie maszyny i trapezoidalny kszta³t si³y elektromotorycznej. Rysunek \ref{fig:2} i \ref{fig:3} przedstawia budowê stojana i wirnika przyk³adowego silnika bezszczotkowego. \cite{krykowski}

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{stojan.png}   
\caption{Stojan silnika BLDC \cite{goryca2012metody}}
\label{fig:2}
\end{figure} 

\begin{figure}[H]
\centering
\includegraphics[width=5cm]{wirnik.png}   
\caption{Wirnik silnika BLDC \cite{goryca2012metody}}
\label{fig:3}
\end{figure} 

\subsection{Zasada dzia³ania}
Silnik elektryczny przetwarza dostarczon¹ energiê elektryczn¹ w energiê mechaniczn¹. Ruch wirnika wystêpuje, gdy zasilaj¹c odpowiednie uzwojenia stojana nastêpuje pojawienie siê wiruj¹cego pola elektromagnetycznego, które oddzia³uje na pole magnetyczne wirnika i wprawia go w ruch. Strumienie magnetyczne wirnika i stojana powinny byæ wzglêdem siebie nieruchome. W klasycznym silniku pr¹du sta³ego powy¿szy warunek jest spe³niony przez odpowiednie umiejscowienie szczotek komutatora wzglêdem pola stojana.
Z powodu braku klasycznego komutatora w silniku BLDC zapewnienie wirowania strumienia stojana synchronicznie z wirnikiem jest realizowane przez odpowiednie prze³¹czanie uzwojeñ. W tym celu 
wykorzystuje siê przetwornik energoelektroniczny, którego zadaniem jest odpowiednie usytuowanie strumieni wzglêdem siebie, poprzez prze³¹czanie tranzystorami mocy. Aby to zrealizowaæ potrzebna jest wiedza o aktualnym po³o¿eniu k¹ta obrotu wirnika, wykorzystuj¹c czujniki Halla lub przetworniki obrotowo-impulsowe.\cite{krykowski}

Na rysunku \ref{fig:4} pokazano uproszczony schemat uk³adu sterowania i zasilania silnika BLDC.
 



\begin{figure}[H]
\centering
\includegraphics[width=8cm]{sterowanie_BLDC.png}   
\caption{Uproszczony schemat uk³adu sterowania i zasilania silnika \cite{domoracki2005silniki}}
\label{fig:4}
\end{figure} 


\subsection{Sposoby sterowania}

Silnik bezszczotkowy  nie posiada konwencjonalnego komutatora , wiêc stale nale¿y kontrolowaæ po³o¿enie wirnika oraz zastosowaæ odpowiedni sposób za³¹czania uzwojeñ. Istniej¹ trzy podstawowe strategie komutacji \cite{krykowski}:
\begin{itemize}
\item Komutacja trapezoidalna – prze³¹czanie uzwojeñ odbywa siê w sposób dyskretny wiêc nie jest potrzebny ci¹g³y pomiar k¹ta obrotu wa³u. Najczêœciej wykorzystujê siê czujniki Halla, które s¹ rozmieszczone w odstêpach 120 stopni lub bezczujnikowe obliczanie po³o¿enia wirnika. Zmiana stanu jednego z czujników inicjujê rozpoczêcie zmiany zasilania uzwojeñ stojana. Zasilane s¹ jednoczeœnie tylko dwa uzwojenia.
\item Komutacja sinusoidalna – prze³¹czanie uzwojeñ odbywa siê w sposób quasi-ci¹g³y. Pr¹dy fazowe i si³y elektromotoryczne powinny byæ sinusoidalne. Przekszta³tnik energoelektroniczny pe³ni funkcje falownika. Do pomiaru po³o¿enia wykorzystuje siê przetwornik impulsowo-obrotowy lub algorytm do bezczujnikowego obliczania k¹ta obrotu wirnika.  Zasilane s¹ jednoczeœnie  trzy  uzwojenia. 
\item Zastosowanie algorytmu FOC (ang. Field Orient Control).\\
 Metoda ta zosta³a wykorzystana w niniejszej pracy i opisana w rozdziale \ref{chapter:1}.
\end{itemize}

\newpage

\subsection{Model matematyczny}
Wartoœæ momentu elektromagnetycznego wytworzonego dla p³askiego fragmentu si³y elektromotorycznej przez pr¹d p³yn¹cy w jednym uzwojeniu fazowym \cite{krykowski}:

\begin{equation} \label{eqn:1}
 Me=p \psi _{p} i 
\end{equation}


Me - moment elektromagnetyczny

p - liczba par biegunów

$\psi _{p}$ -strumieñ magnetyczny wytworzony przez wirnik a skojarzony z uzwojeniem stojana

i - pr¹d uzwojenia stojana 
\\

Chwilowa wartoœæ strumienia skojarzonego z k-tym uzwojeniem zmieniaj¹ca siê w funkcji obrotu wirnika \cite{krykowski}:
\begin{equation} \label{eqn:2}
 \psi _{k}(\theta _{e})=\psi _{p}f(\theta _{e})
\end{equation}

$\theta _{e}$ - elektryczny k¹t po³o¿enia wirnika
\\

£¹cz¹c powy¿sze wyra¿enia \ref{eqn:1} i \ref{eqn:2} uzyskujemy moment elektromagnetyczny dla k-tej fazy \cite{krykowski}:
 
 
\begin{equation} \label{eqn:3}
 M_{ek}=p \psi _{k}(\theta _{e}) i 
\end{equation} 

Moment ca³kowity jest równy sumie momentów elektromagnetycznych\cite{krykowski}:

\begin{equation} \label{eqn:4}
 M_{e}=\sum_{k=1}^{3} M_{ek}
\end{equation} 

Równanie ruch ma postaæ:
\begin{equation} \label{eqn:5}
 M_{e}=J \frac{d\omega}{dt}+M
\end{equation} 

J - moment bezw³adnoœci

M - moment oporowy
\\

Wzór dla p³askiego odcinka si³y elektromotorycznej\cite{krykowski}:

\begin{equation} \label{eqn:6}
 E_{p}=p \psi _{p}\omega
\end{equation} 

$\omega$ - prêdkoœæ obrotowa wirnika 
\\

Wyra¿enie opisuj¹ce si³ê elektromotoryczn¹ indukowan¹ w k-tym uzwojeniu\cite{krykowski}:

\begin{equation} \label{eqn:7}
 E_{k}=p \psi _{k}(\theta _{e})\omega
\end{equation} 
\\
Silnik BLDC mo¿na traktowaæ jako szczególny przypadek silnika synchronicznego.
Schemat zastêpczy silnika trójfazowego z magnesami trwa³ymi przedstawiony na rysunku \ref{fig:5}.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{model_silnik.png}   
\caption{Schemat silnika synchronicznego z magnesami trwa³ymi}
\label{fig:5}
\end{figure} 


M - indukcyjnoœæ wzajemna

L - indukcyjnoœæ w³asna

R - rezystancja uzwojeñ

E - si³a elektromotoryczna
\\

Zak³adaj¹c, ¿e indukcyjnoœci w³asne i rezystancje s¹ równe:\\
\begin{equation} \label{eqn:8}
 L=L_{A}=L_{B}=L_{C}
 R=R_{A}=R_{B}=R_{C}
\end{equation}


oraz indukcyjnoœci wzajemne równie¿ to ca³kowita indukcyjnoœæ  jednej fazy jest równa:

\begin{equation} \label{eqn:9}
 L_{S}=L-M
\end{equation}

Otrzymujemy wyra¿enie \cite{krykowski}:

\begin{equation} \label{eqn:10}
\begin{bmatrix}
U_{A}  \\
U_{B}  \\
U_{C}  \\
\end{bmatrix}
= R
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
I_{A}  \\
I_{B}  \\
I_{C}  \\
\end{bmatrix}
+L_{S}\frac{d}{dt}
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
I_{A}  \\
I_{B}  \\
I_{C}  \\
\end{bmatrix}
+
\begin{bmatrix}
E_{A}  \\
E_{B}  \\
E_{C}  \\
\end{bmatrix}
\end{equation} 

oraz

\begin{equation} \label{eqn:11}
\frac{d}{dt}
\begin{bmatrix}
I_{A}  \\
I_{B}  \\
I_{C}  \\
\end{bmatrix}
= - \frac{R}{L}
\begin{bmatrix}
1 & 0 & 0 \\
0 & 1 & 0 \\
0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
I_{A}  \\
I_{B}  \\
I_{C}  \\
\end{bmatrix}
-\frac{1}{L}
\begin{bmatrix}
E_{A}  \\
E_{B}  \\
E_{C}  \\
\end{bmatrix}
+\frac{1}{L}
\begin{bmatrix}
U_{A}  \\
U_{B}  \\
U_{C}  \\
\end{bmatrix}
\end{equation}
\\

Wykorzystuj¹c równanie \ref{eqn:3}, \ref{eqn:5}, \ref{eqn:7}, \ref{eqn:11} i zapis \ref{eqn:12} w postaci równaæ stanu uzyska siê pe³en model idealnego silnika o trapezoidalnej sile elektromotorycznej \cite{krykowski}:

\begin{equation} \label{eqn:12}
 \hat{x}=Ax+Bu
\end{equation} 

gdzie:

\begin{equation} \label{eqn:13}
 x=
\begin{bmatrix}
I_{A}  & I_{B}  & I_{C} & \omega & \theta
\end{bmatrix}^{T}
\end{equation} 

\begin{equation} \label{eqn:14}
 u=
\begin{bmatrix}
U_{A}  & U_{B}  & U_{C} & M
\end{bmatrix}^{T}
\end{equation} 

\begin{equation} \label{eqn:15}
 A=
\begin{bmatrix}
-\frac{R}{L}  & 0  & 0 & -p\psi_{A}(\theta_{e})/L & 0\\
0  & -\frac{R}{L}  & 0 & -p\psi_{B}(\theta_{e})/L & 0\\
0  & 0  & -\frac{R}{L} & -p\psi_{C}(\theta_{e})/L & 0\\
-p\psi_{A}(\theta_{e})/J & -p\psi_{B}(\theta_{e})/J & -p\psi_{C}(\theta_{e})/J & -B/J & 0 \\
0 & 0 & 0 & 1 & 0
\end{bmatrix}
\end{equation} 


\begin{equation} \label{eqn:16}
 B=
\begin{bmatrix}
1/L & 0 & 0 & 0 \\
0 & 1/L & 0 & 0 \\
0 & 0 & 1/L & 0 \\
0 & 0 & 0 & 1/L \\
0 & 0 & 0 & 0 \\
\end{bmatrix}
\end{equation} 




\subsection{Charakterystyka silnika - wady, zalety}
Brak konwencjonalnego komutatora wyd³u¿a ¿ywotnoœæ silnika i nie wymaga konserwacji.  Brak szczotek powoduje mniejsze tarcie, brak negatywnych skutków iskrzenia podczas komutacji oraz mniejsze zaburzenia elektromotoryczne. W porównaniu ze szczotkowym silnikiem pr¹du sta³ego uzwojenia twornika s¹ zazwyczaj umieszczone w zewnêtrznej czêœci silnika, co zapewnia lepsze odprowadzanie ciep³a do otoczenia. Magnesy trwa³e maj¹ bardzo ma³¹ przenikalnoœæ magnetyczn¹ zbli¿on¹ do przenikalnoœci magnetycznej powietrza. Reaktancja twornika jest pomijalnie ma³a dziêki czemu osi¹gany jest du¿y moment elektromagnetyczny. Do wad nale¿y zaliczyæ bardziej skomplikowany sposób sterowania silnikiem przez zastosowanie komutatora elektronicznego w postaci przekszta³tnika energoelektronicznego do cyklicznego zasilania uzwojeñ twornika. 




\section{Sterowanie Zorientowane Polowo}
 \label{chapter:1}
 
 Algorytm Sterowania Zorientowanego Polowo FOC przedstawiony schematycznie na rysunku \ref{fig:6} jest jedn¹ z powszechnie stosowanych metod sterowania silników trójfazowych z magnesami trwa³ymi. Polega na bezpoœrednim sterowaniu wiruj¹cym polem stojana.  Pozwala uzyskaæ dok³adn¹ i dynamiczn¹ regulacjê momentu elektrodynamicznego, prêdkoœci i po³o¿enia wirnika.\cite{Przepiorkowski2010FOC}
 \\
 
\begin{figure}[H]
\centering
\includegraphics[width=14cm]{diagramFOC.png}   
\caption{Algorytm FOC \cite{Frick2018BLDC}}
\label{fig:6}
\end{figure} 
 
Metoda FOC steruje pr¹dami fazowymi stojana reprezentowanymi w postaci wektora. Czujniki pr¹du dostarczaj¹ informacjê zwrotn¹ o aktualnych pr¹dach fazowych. Transformata Clark’a, wyra¿ona za pomoc¹ wzoru   \ref{eqn:17} i pokazana na rysunku \ref{fig:7},   przekszta³ca trójwymiarowy uk³ad wspó³rzêdnych, w którym opisane s¹ pr¹dy fazowe Ia,Ib,Ic na uk³ad ograniczony do dwóch wspó³rzêdnych otrzymuj¹c wiruj¹cy wektor na p³aszczyŸnie. Znaj¹c aktualne po³o¿enie wirnika i korzystaj¹c z transformaty Park’a, wyra¿ona we wzorze \ref{eqn:18} i pokazana na rysunku \ref{fig:8}, uzyskujemy wiruj¹cy uk³ad wspó³rzêdnych. Operacja ta pozwala  na przekszta³cenie wiruj¹cego wektora pr¹du na dwie sk³adowe sta³e:
 strumienia magnetycznego Id oraz momentu elektromagnetycznego Iq. Daje to mo¿liwoœæ sterowania w sposób rozdzielny pr¹dem odpowiedzialnym za moment obrotowy oraz wzbudzeniem wytwarzaj¹cym strumieñ magnetyczny skojarzony z twornikiem. Minimalizuj¹c wartoœæ Id zapewniamy k¹t prosty miêdzy polem magnetycznym stojana i wirnika oraz uzyskujemy najwiêksza sprawnoœæ silnika.\cite{Przepiorkowski2010FOC}
\cite{europe1998field}
\\


\begin{figure}[H]
\centering
\includegraphics[width=7cm]{clark.png}   
\caption{Transformata Clark'a \cite{europe1998field}}
\label{fig:7}
\end{figure} 

Wyra¿enie opisuj¹ce transformatê Clark'a \cite{Przepiorkowski2010FOC}:

\begin{equation} \label{eqn:17}
\left\{ \begin{array}{ll}
I_{\alpha}=I_{A}\\
I_{\beta}=\frac{1}{\sqrt{3}}I_{A}+\frac{2}{\sqrt{3}}I_{B} \\
\end{array} \right. 
\end{equation} 
\\




\begin{figure}[H]
\centering
\includegraphics[width=8cm]{park.png}   
\caption{Transformata Park'a \cite{europe1998field}}
\label{fig:8}
\end{figure} 

Wyra¿enie opisuj¹ce transformatê Park'a \cite{Przepiorkowski2010FOC}:

\begin{equation} \label{eqn:18}
\left\{ \begin{array}{ll}
I_{d}=I_{\alpha}cos(\theta)+I_{\beta}sin(\theta)\\
I_{q}=I_{\alpha}sin(\theta)+I_{\beta}cos(\theta)
\end{array} \right. 
\end{equation} 
\\

 
Przekszta³cenie przebiegów pr¹dów przemiennych w dwie sk³adowe sta³opr¹dowe pozwala na zastosowanie regulatorów PID dla sk³adowej Id oraz Iq uzyskuj¹c regulator pr¹du i wzbudzenia. Regulacje prêdkoœci obrotowej i po³o¿enia wirnika jest zrealizowana przez dodanie kolejnych regulatorów PID do ga³êzi ze sta³¹ Iq. 
 

Zastosowanie odwrotnych transformat pozwala na sprowadzenie sk³adowych sta³ych do trzch przebiegów sinusoidalnych i wprowadzenie ich wartoœci na kolejny blok algorytmu FOC zwany SVPWM (ang. Space Vector Pulse Width Mudulation) opisany w rozdziale \ref{chapter:2}. Blok ten steruje bramkami tranzystorów przetwornika, aby uzyskaæ w uzwojeniach takie przebiegi pr¹dów, które bêd¹ generowa³y odpowiedni¹ amplitudê i prêdkoœæ wirowania pola magnetycznego stojana wzglêdem pola wirnika. Rysunek \ref{fig:9} przedstawia kolejnoœæ dokonywanych transformacji.

 \begin{figure}[H]
\centering
\includegraphics[width=14cm]{transformacje.png}   
\caption{Transformacje w algorytmie FOC \cite{Frick2018BLDC}}
\label{fig:9}
\end{figure}  

\newpage

\section{Modulacja wektorowa - SVPWM}
 \label{chapter:2}
 
 Wydajnoœæ pr¹dowa mikrokontrolera jest niewystarczaj¹ca aby zasiliæ silnik, dlatego uzwojenia stojana s¹ bezpoœrednio pod³¹czone do przekszta³tnika energoelektronicznego zasilanego napiêciem sta³ym. Schemat przekszta³tnika przedstawia rysunek \ref{fig:4}. SVPWM jest meted¹ pozwalaj¹c¹ okreœliæ, sekwencje i czas trwania za³¹czeñ tranzystorów. W porównaniu z konwencjonaln¹ metod¹ SPWM (ang. Sine Pulse Width Modulation) do sterowania silników synchronicznych, pozwala na wykorzystanie szerszego zakresu napiêcia zasilania i zmniejszenia zniekszta³ceñ spowodowanych przez wy¿sze harmoniczne.\cite{mansour2015novel}

 Elementami wykonawczymi s¹ tranzystory mocy, które mo¿na podzieliæ na grupê trzech zaworów dodatnich i ujemnych. W ka¿dej chwili aktywne s¹ trzy zawory. W ten sposób uzyskujemy osiem mo¿liwych kombinacji za³¹czeñ tranzystorów, które generuj¹ osiem wektorów (szeœæ wektorów aktywnych, dwa wektory zerowe lub nieaktywne) i dziel¹ przestrzeñ na szeœæ sektorów  - schematycznie przedstawiono na rysunku \ref{fig:10}. 

 \begin{figure}[H]
\centering
\includegraphics[width=7cm]{hexagon.png}   
\caption{Wektory w przestrzeni stanu i podzia³ na sektory \cite{Frick2018BLDC}}
\label{fig:10}
\end{figure} 

Maksymalne napiêcie fazowe jest równe 2/3 VDC. Aby uzyskaæ nieodkszta³cony przebieg sinusoidalny maksymalne napiêcie szczytowe jest ograniczone do wartoœci promienia  okrêgu
wpisanego w szeœciok¹t i jest równe $ V_{max}=V_{dc}  \sqrt{3}/2$. Powy¿sze za³o¿enie przedstawiono na rysunku \ref{fig:11}.\cite{mansour2015novel}

 \begin{figure}[H]
\centering
\includegraphics[width=8cm]{svpwm_max.png}   
\caption{Maksymalna d³ugoœæ wektora  \cite{Frick2018BLDC}}
\label{fig:11}
\end{figure}  
 
Na przyk³adzie rysunku \ref{fig:12} zosta³ objaœniony sposób generowania dowolnego wektora wed³ug metody SVPWM.  Wektor Vx znajdujê siê w sektorze pierwszym i jest wynikiem dodania do siebie trzech wektorów $V_{A}$, $V_{B}$, $V_{0}$, gdzie $V_{0}$ jest wektorem zerowym.\cite{mansour2015novel}


 \begin{figure}[H]
\centering
\includegraphics[width=7cm]{svpwm.png}   
\caption{Generowanie wektora $V_{X}$ \cite{mansour2015novel}}
\label{fig:12}
\end{figure} 

Dla sektora pierwszego wektor $V_{A}$ jest zgodny z kierunkiem wektora $V_{1}$ a wektor $V_{B}$ z kierunkiem wektora $V_{2}$. D³ugoœæ obu wektorów jest determinowana przez czas, w którym dana sekwencja zaworów (reprezentowana przez okreœlony wektor V1,…,V6) jest aktywna.\cite{mansour2015novel} 

Z równania \cite{mansour2015novel}:

\begin{equation} \label{egn:19}
\left\{ \begin{array}{ll}
|V_{x}| cos(\alpha)\times T_{s} = V_{DC} \times T_{A} + V_{DC} \times cos(\pi/3) \times T_{B}\\
|V_{x}| sin(\alpha)\times T_{s} = V_{DC} \times sin(\pi/3) \times T_{B}
\end{array} \right. 
\end{equation} 

\noindent oraz z wyra¿enia \ref{egn:20}, które pozwala zredukowaæ k¹t $\alpha $ do przedzia³u od 0 do $\pi/3$ \cite{bouanane2019design} :
\begin{equation} \label{egn:20}
\theta=\phi-\frac{k-1}{3}\pi 
\end{equation} 
gdzie: k - sektor {1..6}


\noindent mo¿na wyznaczyæ zale¿noœæ pozwalaj¹c¹ okreœliæ czasy $T_{A}$, $T_{B}$ generowania wektorów $V_{A}$, $V_{B}$ dla  dowolnego sektora \cite{bouanane2019design} :

\begin{equation} \label{egn:21}
\left\{ \begin{array}{ll}
T_{A} = \frac{\sqrt{3} T_{s} V_{x}}{V_{DC}} (sin(k\pi/3 - \theta))\\
T_{B} = \frac{\sqrt{3} T_{s} V_{x}}{V_{DC}} (sin((k-1)\pi/3 - \theta))
\end{array} \right. 
\end{equation} 


Suma czasów $T_{A}$, $T_{B}$ i $T_{0}$ jest równa okresowi modulacji szerokoœci impulsów $T_{S}$.

Znaj¹c sektor i czasy $T_{A}$, $T_{B}$, $T_{0}$ mo¿na wygenerowaæ dowolny wektor w przestrzeni stanu. Aby tego dokonaæ nale¿y zastosowaæ odpowiedni¹ sekwencjê za³¹czeñ wektorów $V_{A}$, $V_{B}$, $V_{0}$. Wektory te, w zale¿noœci od sektora, w którym siê znajduj¹, maj¹ swoj¹ reprezentacje w odpowiadaj¹cej im kombinacji za³¹czeñ kluczy tranzystorów przekszta³tnika.  Rysunek \ref{fig:13} przedstawia sekwencje wektorów $V_{A}$, $V_{B}$, $V_{0}$ i czasy ich aktywnoœci w zale¿noœci od umiejscowienia wektora referencyjnego w przestrzeni stanu. W wyniku powy¿szych operacji otrzymujemy trzy sygna³y PWM dla ka¿dej ga³êzi trójfazowego przekszta³tnika \cite{luczak2014comparison}.

 \begin{figure}[H]
\centering
\includegraphics[width=10cm]{sektor.png}   
\caption{Sekwencja generowania wektora referencyjnego} 
\label{fig:13}
\end{figure} 


\section{Realizacja uk³adu napêdowego z silnikiem BLDC}
\subsection{Realizacja sprzêtowa}
Realizacja praktyczna uk³adu napêdowego jest przedstawiona na rysunku \ref{fig:14}.


 \begin{figure}[H]
\centering
\includegraphics[width=12cm]{naped1.png}   
\caption{Napêd z silnikiem BLDC}
\label{fig:14}
\end{figure} 





\subsection{Spis urz¹dzeñ}

\begin{enumerate}
\item Silnik bezszczotkowy FXD57BL 24 VDC.
\item Przetwornik obrotowo-impulsowy N38G6-720-BM-8-30FG2.
\item Zestaw rozwojowy STM32 B-G431B-ESC1.
\item Zestaw rozwojowy STM32 Nucleo F746ZG.
\item  Czujnik pr¹du Pololu 1185 ACS714 -5A : +5A.
\item  Czujnik pr¹du Pololu 1185 ACS714 -5A : +5A.
\item  Czujnik pr¹du Pololu 1185 ACS714 -5A : +5A.
\item  Zasilacz laboratoryjny KORAD 0-30V, 0-5A.
\end{enumerate}



\subsection{Schemat elektryczny}


 \begin{figure}[H]
\includegraphics[scale=0.65]{schemat_el.pdf}   
\label{fig:15}
\end{figure} 

\subsection{Opis i dane techniczne urz¹dzeñ}

\begin{enumerate}
\item Silnik bezszczotkowy FXD57BL 24 VDC

Silnik wykorzystany do budowy napêdu pokazany na rysunku \ref{fig:16}
 
Parametry techniczne:
\begin{itemize}
\item moc: 60W,
\item napiêcie zasilania: 24 V,
\item pr¹d znamionowy: 3.3 A,
\item maksymalna prêdkoœæ obrotowa: 3000 obr/min,
\item moment znamionowy: 0,18 Nm,
\item wirnik dwupolowy, 
\item d³ugoœæ silnika: 55 mm.
\end{itemize}

 \begin{figure}[H]
\centering
\includegraphics[width=10cm]{silnik_bldc.png}   
\caption{Silnik BLDC}
\label{fig:16}
\end{figure} 



\item Inkrementalny przetwornik obrotowo-impulsowy N38G6-720-BM-8-30FG2

Przetwornik obrotowo-impulsowy inaczej enkoder jest czujnikiem mierz¹cym ruch. Przekszta³ca ruch obrotowy 
w sygna³ elektryczny o przebiegu prostok¹tnym. Enkoder inkrementalny nie generuje informacji o po³o¿eniu bezwzglêdnym.

Parametry techniczne:
\begin{itemize}
\item rozdzielczoœæ: 720 impulsów/obrót,
\item napiêcie zasilania: 5 - 30 VDC,
\item rodzaj wyjœcia: PUSH - PULL,
\item maksymalny pobór pr¹du: 150 mA,
\item maksymalne obci¹¿enie pr¹dowe:	30 mA,
\item maksymalna czêstotliwoœæ:	150 kHz,
\item znamionowa prêdkoœæ pracy:	5000 obr/min.
\end{itemize}



\item Zestaw rozwojowy STM32 B-G431B-ESC1


Zestaw rozwojowy B-G431B-ESC1 firmy STMicroelectronics  oparty na mikrokontrolerze STM32G431CB jest dedykowanym uk³adem elektronicznym dla napêdów z silnikami BLDC/PMSM. Posiada przekszta³tnik energoelektroniczny zbudowany w oparciu o sterowniki L6387 i tranzystory mocy MOSFET STL180N6F7. Dla sterowania i monitorowania prac¹ silnika oraz do wspó³pracy  z innymi uk³adami zapewnia ró¿ne sposoby komunikacji  - UART, CAN i PWM. STM32G431CB wyposa¿ony w procesor  ARM Cortex M4 32-bity, pe³en zestaw instrukcji DSP (ang. Digital Signal Processing)   oraz blok do przetwarzania liczb zmiennoprzecinkowych FPU (ang. Floating-Point Unit) zapewnia mo¿liwoœæ implementacji ró¿nych zaawansowanych algorytmów sterowania. Posiada wbudowane uk³ady mierz¹ce pr¹d w silniku. Rysunek \ref{fig:17} przedstawia najistotniejsze elementy wbudowane w uk³ad B-G431B-ESC1.\cite{B-G431}



Parametry techniczne B-G431B-ESC1 \cite{B-G431}:
\begin{itemize}
\item napiêcie znamionowe 60 V,
\item maksymalny pr¹d szczytowy (z uk³adem ch³odzenia): 40 A.
\end{itemize}

Parametry techniczne STM32G431CB \cite{B-G431}:
\begin{itemize}
\item procesor: ARM Cortex M4 32-bity DSP,
\item czêstotliwoœæ taktowania procesora: 170 MHz,
\item pamiêæ Flash: 128 KB,
\item pamiêæ SRAM: 32 KB,
\item przetwornik analogowo-cyfrowy 12-bitowy: 2,
\item komparatory: 4,
\item wbudowane wzmacniacze operacyjne: 3,
\item kontroler DMA,
\item interfejsy: UART, PWM, CAN.
\end{itemize}


 \begin{figure}[H]
\centering
\includegraphics[width=14cm]{B-G431.png}   
\caption{Zestaw rozwojowy STM32 B-G431-ESC1 \cite{B-G431}}
\label{fig:17}
\end{figure} 

\item Zestaw rozwojowy STM32 Nucleo F746ZG

Nucleo F746ZG jest zestawem rozwojowym opartym na mikrokontrolerze STM32F746Z. Du¿a iloœæ peryferiów oraz wyprowadzonych pinów do ich pod³¹czenia zapewnia wiele mo¿liwoœci prototypownia. Posiada wbudowany programator ST-LINK/V2-1 oraz z³¹cze RJ-45 do po³¹czenia sieciowego. Rysunek \ref{fig:18} przedstawia  uk³ad 
Nucleo F746ZG.

Parametry techniczne mikrokontrolera STM32F746Z \cite{stm32f7}:
\begin{itemize}
\item procesor: ARM Cortex M7 32-bity FPU, DSP,
\item czêstotliwoœæ taktowania procesora: 216 MHz,
\item pamiêæ Flash: 1 MB,
\item pamiêæ SRAM: 320 KB,
\item przetwornik analogowo-cyfrowy 12-bitowy: 3,
\item liczniki: 18,
\item przetwornik cyfrowo-analogowe 12-bitowy: 2,
\item interfejsy: UART,USART, $I^2 C$, SPI, CAN, SAIs, HDMI, USB,
\item kontroler DMA.
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=8cm]{nucleo.png}   
\caption{Zestaw rozwojowy STM32 Nucleo F746ZG \cite{nucleo}}
\label{fig:18}
\end{figure} 
 


\end{enumerate}

\subsection{Konfiguracja ustawieñ mikrokontrolerów}
Do konfiguracji ustawieñ mikrokontrolerów w uk³adach rozwojowych STM32 B-G431-ESC1 i Nucleo F746ZG wykorzystano aplikacje STM32CubeMX. Umo¿liwia ona w sposób wizualny dokonaæ 
dowolnych zmian w mikroprocesorze i w peryferiach. Po zachowaniu ustawieñ zostaje wygenerowany plik w jêzyku C, który implementuje wszystkie dokonane modyfikacje. 

\subsubsection{STM32G431CB}

Zestaw prototypowy B-G431-ESC1 wyposa¿ony jest w mikrokontroler STM32G431CB. Rysunek
\ref{fig:50}, \ref{fig:52} przedstawia konfiguracjê, opis wykorzystanych pinów i ustawienia 
czêstotliwoœci taktowania poszczególnych peryferii za pomoc¹ aplikacji STM32CubeMX. 

Dokonane ustawienia:
\begin{itemize}
\item {PA8, PA9, PA10, PA12, PC13, PB15 s¹ wyjœciami kana³ów licznika 1, które generuj¹ 
trzy sygna³y PWM dla bramek tranzystorów MOSFET przetwornika energoelektronicznego,}
\item {PA11 jest wyjœciem kana³u licznika 1 do wyzwalania konwersji 
przetworników ADC oraz synchronizacji pomiarów czujników z uk³adem Nucleo F746ZG,} 
\item {PB4, PB3 - port szeregowy UART o przepustowoœci 115200 Bits/s,}
\item {PB8 jest wejœciem licznika 8 dla jednego z kana³ów przetwornika obrotowo-impulsowego s³u¿¹cego do pomiaru prêdkoœci. Licznik jest ustawiony w trybie Reset Mode co oznacza ¿e ka¿de zbocze narastaj¹ce resetuje jego wartoœæ, dziêki czemu mo¿na wyznaczyæ okres miêdzy impulsami.}
\item {PB7, PB6 s¹ wejœciami licznika 4 dla kana³ów przetwornika obrotowo-impulsowego.
Licznik jest ustawiony w trybie Encoder Mode, który pozwala na dodawanie i odejmowanie
zliczonych impulsów z przetwornika w zale¿noœci od kierunku obrotu.}
\item {Piny oznaczone jako OPAMPx\_VOUT ADCx\_INx s¹ wyjœciami wzmacniacza operacyjnego, 
który zosta³ wewnêtrznie pod³¹czony do przetwornika ADC w celu pomiaru pr¹dów fazowych - patrz rozdzia³ \ref{chapter:OPAMP},}
\item {piny oznaczone jako OPAMPx\_VINP oraz OPAMPx\_VINM s¹ wejœciami wzmacniacza operacyjnego,}
\item {przetwornik ADC inicjuje wywo³anie funkcji obs³ugi zdarzenia po zakoñczeniu wszystkich pomiarów,}
\item {PC10 jest pinem przypisanym do przycisku, który realizuje funkcje uruchomienia i 
zatrzymania napêdu.}
\end{itemize}


 \begin{figure}[H]
\centering
\includegraphics[scale=0.65]{CubeMx_driver.png}   
\caption{Konfiguracja mikrokontrolera STM32G431}
\label{fig:50}
\end{figure} 

 \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{clock_sterownik.png}   
\caption{Konfiguracja zegara i czêstotliwoœci taktowania peryferii STM32G431}
\label{fig:52}
\end{figure} 

\subsubsection{STM32F746ZG}

Zestaw prototypowy STM32 Nucleo F746ZG wyposa¿ony jest w mikrokontroler STM32F746ZG. Rysunek \ref{fig:51}, \ref{fig:53} przedstawia konfiguracjê, opis wykorzystanych pinów i
ustawienia czêstotliwoœci taktowania poszczególnych peryferii za pomoc¹ aplikacji STM32CubeMX. 

Dokonane ustawienia:
\begin{itemize}
\item{PC1, PA1, PA2, PA7, PC4, PC5, PB13, PG11, PG13 tworz¹ interfejs Ethernet w trybie RMII,}
\item{PA4, PA6, PB1 s¹ kana³ami przetowrników ADC do pomiarów pr¹dów fazowych,}
\item {PE9 jest wejœciem kana³u licznika 1 do wyzwolenia konwersji 
przetworników ADC oraz synchronizacji pomiarów czujników ze sterownikiem B-G431-ESC1,} 
\item {PD5, PA3 - port szeregowy UART o przepustowoœci 115200 Bits/s,}
\item {PC6 jest wejœciem licznika 8 dla jednego z kana³ów przetwornika obrotowo-impulsowego s³u¿¹cego do pomiaru prêdkoœci. Licznik jest ustawiony w trybie Reset Mode co oznacza ¿e ka¿de zbocze narastaj¹ce resetuje jego wartoœæ, dziêki czemu mo¿na wyznaczyæ okres miêdzy impulsami.}
\item {PD12, PD13 s¹ wejœciami licznika 4 dla kana³ów przetwornika obrotowo-impulsowego.
Licznik jest ustawiony w trybie Encoder Mode, który pozwala na dodawanie i odejmowanie
zliczonych impulsów z przetwornika w zale¿noœci od kierunku obrotu.}
\end{itemize}


 \begin{figure}[H]
\centering
\includegraphics[scale=0.68]{CubeMx_Nucleo.png}   
\caption{Konfiguracja mikrokontrolera STM32F746ZG}
\label{fig:51}
\end{figure} 

 \begin{figure}[H]
\centering
\includegraphics[scale=0.5]{clock_nucleo.png}   
\caption{Konfiguracja zegara i czêstotliwoœci taktowania peryferii STM32F746ZG}
\label{fig:53}
\end{figure} 
    
\subsubsection{Przedstawienie g³ównych funkcji w kodzie Ÿród³owym}

Kod programu zosta³ napisany za pomoc¹ aplikacji STM32CubeIDE w jêzyku C.
Listing \ref{listing:1} przedstawia wybrane funkcje i ich opis w postaci komentarzy.

 \begin{lstlisting}[label=etykieta, caption={\label{listing:1}}, language=C++]
//funkcja inicjalizuj¹ca - uruchamiana przy starcie programu 
//przypisana do przycisku WYŒLIJ USTAWIENIA przy pierwszym uruchomieniu (interfejs u¿ytkownika)
//wyzerowanie po³o¿enia wirnika, uruchamia liczniki, przetworniki ADC 
//inicjalizuje struktury regulatorów PID  
void start_up(void)
{
	if(HAL_OK== ((HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED)) && (HAL_ADCEx_Calibration_Start(&hadc2, ADC_SINGLE_ENDED))) )
	{
		if(HAL_OK== (HAL_OPAMPEx_SelfCalibrateAll(&hopamp1, &hopamp2, &hopamp3)))
		{
		//linia 10 - 45 algorytm wyzerowania po³o¿enia wirnika
		
			//ustawienie licznika TIM1 odpowiedzialnego za generowanie sygna³ów PWM
			TIM1->ARR= TIM1_ARR;
			TIM1->PSC= TIM1_PSC;

			TIM1->CCR1=(TIM1->ARR/10);
			TIM1->CCR2=0;
			TIM1->CCR3=0;
			TIM1->CCR4=TIM1_CCR4;

			HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
			HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_1);
			HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
			HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);
			HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
			HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3);
			//HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);

			HAL_Delay(800);

			//uruchomienie licznika do wyznaczenia k¹ta po³o¿enia wirnika
			TIM4->ARR= TIM4_ARR;
			TIM4->PSC= TIM4_PSC;
			HAL_TIM_Base_Start_IT(&htim4);
			HAL_TIM_Encoder_Start_IT(&htim4, TIM_CHANNEL_1);
			HAL_TIM_Encoder_Start_IT(&htim4, TIM_CHANNEL_2);

			HAL_Delay(400);

			TIM1->CCR1=0;
			TIM1->CCR2=0;
			TIM1->CCR3=0;

			HAL_Delay(200);

			//uruchomienie licznika do wyznaczenia prêdkoœci obrotowej wirnika
			TIM8->ARR= TIM8_ARR;
			TIM8->PSC= TIM8_PSC;
			HAL_TIM_IC_Start(&htim8, TIM_CHANNEL_2);


			//uruchomienie wzmacniaczy operacyjnych dla przetowrników ADC
			HAL_OPAMP_Start(&hopamp1);
			HAL_OPAMP_Start(&hopamp2);
			HAL_OPAMP_Start(&hopamp3);
			
			//uruchomienie przetworników ADC z obs³ug¹ zdarzeñ
			HAL_ADCEx_InjectedStart_IT(&hadc1);
			HAL_ADCEx_InjectedStart_IT(&hadc2);

			//inicjalizacja struktur regulatorów PID
			set_d=0;
			pid_d.Kp=1;
			pid_d.Ki=1;
			pid_d.Kd=0;
			arm_pid_init_f32(&pid_d, 1);

			//regulator pr¹du Id
			set_q=0.7;
			pid_q.Kp=4;
			pid_q.Ki=1;
			pid_q.Kd=0;
			arm_pid_init_f32(&pid_q, 1);

			//regulator pr¹du Iq
			set_speed=2200;
			pid_iq_speed.Kp=5;
			pid_iq_speed.Ki=5;
			pid_iq_speed.Kd=0;
			arm_pid_init_f32(&pid_iq_speed, 1);

			//regulator prêdkoœci
			set_angle=20000;
			pid_angle.Kp=5;
			pid_angle.Ki=5;
			pid_angle.Kd=0;
			arm_pid_init_f32(&pid_angle, 1);
		}
	}

}

// funkcja odpowiedzialna za uruchomienie generowania sygna³ów PWM
// przypisana do przycisku START(interfejs u¿ytkownika), uruchamia napêd 
void start1(void)
{
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);
	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_1);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_2);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
	HAL_TIMEx_PWMN_Start(&htim1, TIM_CHANNEL_3);
	HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_4);
}

// funkcja odpowiedzialna za zatrzymanie generowania sygna³ów PWM
// przypisana do przycisku STOP(interfejs u¿ytkownika), zatrzymujê napêd
void stop(void)
{

	TIM1->CCR1=0;
	TIM1->CCR2=0;
	TIM1->CCR3=0;

	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_1);
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_1);
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_2);
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_3);
	HAL_TIMEx_PWMN_Stop(&htim1, TIM_CHANNEL_3);
	HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_4);

	arm_pid_reset_f32(&pid_d);
	arm_pid_reset_f32(&pid_q);
	arm_pid_reset_f32(&pid_iq_speed);
	arm_pid_reset_f32(&pid_angle);

}


// funkcja pobiera wspó³rzêdne wektora [alpha, beta] i oblicza modu³ oraz k¹t 
void AlphaBeta_To_Angle_Vref(float32_t alpha,float32_t beta,float32_t *angle_current_rad,float32_t *Vref)
{
	*angle_current_rad = atan2f(beta,alpha);
	arm_sqrt_f32( ((alpha*alpha)+(beta*beta)), Vref);

	 if(*Vref>=sv_Vdc_limit)  // saturacja Vref
	    	*Vref=sv_Vdc_limit;
}

// funkcja pobiera k¹t wektora [rad] i oblicza w którym sektorze znajdujê siê ten wektor
void Angle_To_Sector(float32_t angle_current_rad,uint8_t *sector)
{

	if((angle_current_rad>0) && (angle_current_rad<=1.047197)) // pi/3
		*sector=1;
	else if((angle_current_rad>1.047197) && (angle_current_rad<=2.094395)) //2/3*pi
		*sector=2;
	else if((angle_current_rad>2.094395) && (angle_current_rad<=3.141593))
		*sector=3;
	else if((angle_current_rad>-3.141593) && (angle_current_rad<=-2.094395))
		*sector=4;
	else if((angle_current_rad>-2.094395) && (angle_current_rad<=-1.047197))
		*sector=5;
	else if ((angle_current_rad>-1.047197) && (angle_current_rad<=0))
		*sector=6;
	else{}

}

// funkcja pobiera k¹t, modu³ wektora i numer sektora w którym wektor siê znajdujê
// na podstawie tych informacji oblicza szerokoœæ
// wype³nienia impulsów dla trzech sygna³ów PWM
void SVPWM(uint8_t sector,float32_t angle_current_rad,float32_t Vref, float32_t T[], float32_t T_gate[], float32_t *S1,float32_t *S2,float32_t *S3)
{

	T[1]= (1.7320508 * (( Vref * sv_Tz)/Vdc)) * arm_sin_f32((sector * 1.047197) - (angle_current_rad)); /// pi/3 = 1,0472  sqrt(3)=1.7320508
	T[2]= (1.7320508 * (( Vref * sv_Tz)/Vdc)) * arm_sin_f32((-(sector-1) * 1.047197) +  angle_current_rad) ;
	T[0]=sv_Tz-T[1]-T[2];

	t1=T[1];
	t2=T[2];
	t3=T[0];

	T_gate[0]= (T[0]/2);
	T_gate[1]= T[1]+(T_gate[0]);
	T_gate[2]= T[2]+(T_gate[0]);
	T_gate[3]= T[1]+T[2]+(T_gate[0]);


	if(sector == 1)
	{
		*S1=T_gate[3];
		*S2=T_gate[2];
		*S3=T_gate[0];
	}
	else if(sector == 2)
	{
		*S1=T_gate[1];
		*S2=T_gate[3];
		*S3=T_gate[0];
	}
	else if(sector == 3)
	{
		*S1=T_gate[0];
		*S2=T_gate[3];
		*S3=T_gate[2];
	}
	else if(sector == 4)
	{
		*S1=T_gate[0];
		*S2=T_gate[1];
		*S3=T_gate[3];
	}
	else if(sector == 5)
	{
		*S1=T_gate[2];
		*S2=T_gate[0];
		*S3=T_gate[3];
	}
	else if(sector == 6)
	{
		*S1=T_gate[3];
		*S2=T_gate[0];
		*S3=T_gate[1];
	}
	else{}

}

// funkcja obs³ugi zdarzenia wywo³ywana po zakoñczeniu konwersji ADC
// g³ówna funkcja odpowiedzialna za dokonywanie obliczeñ uk³adów regulacji
void HAL_ADCEx_InjectedConvCpltCallback(ADC_HandleTypeDef *hadc)
{
	// obliczanie prêdkoœci obrotowej wirnika
	capture_tim8_ccr2= TIM8->CCR2;
	speed=revolution_per_min/capture_tim8_ccr2;
	
	// sprawdzenie kierunku obrotu 
	//do zmiennej direction jest przypisany bit z rejestru CR1 licznika
    // który zawiera informacje o tym czy licznik jest inkrementowany czy dekrementowany 
	if(direction!=0)  
	speed=-speed;
	
    // odczytanie wartoœci pr¹dóW z przetowrników ADC
	adc_Ia= HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_1);
    while((hadc1.Instance->ISR &= (0x1<<5))!=0){}
    adc_Ic =HAL_ADCEx_InjectedGetValue(&hadc1, ADC_INJECTED_RANK_2);
	while((hadc1.Instance->ISR &= (0x1<<5))!=0){}
	adc_Ib =HAL_ADCEx_InjectedGetValue(&hadc2, ADC_INJECTED_RANK_1);
	while((hadc2.Instance->ISR &= (0x1<<5))!=0){}

	// wyznaczenie offsetu dla przetwornika ADC
	if(index_event_adc<300)
	{
		Ia=0;
		Ib=0;
		Ic=0;
		index_event_adc++;


	}
	else if(index_event_adc == 300)
	{
	    offset1=adc_Ia;
		offset2=adc_Ib;
		offset3=adc_Ic;
		index_event_adc++;
	}
	else
	{

	    adc_Ia=(adc_Ia-offset1);
	    adc_Ib=(adc_Ib-offset2);
	    adc_Ic=(adc_Ic-offset3);
	    
		// konwersja wartosci ADC na wartoœc wyra¿on¹ w amperach [A]
	    Ia=-adc_Ia/33.0;
	    Ib=-adc_Ib/33.0;
	    Ic=-adc_Ic/33.0;
	    	    
		// transformacja clark'a
	    arm_clarke_f32(Ia, Ib, &Ialpha, &Ibeta);
	    
	    angle_rotor_deg=TIM4->CCR1;
	    arm_sin_cos_f32(angle_rotor_deg, &pSinVal, &pCosVal);
	    
	    // transformacja park'a
	    arm_park_f32(Ialpha, Ibeta, &Id, &Iq, pSinVal, pCosVal);

	    // obliczanie po³o¿enia wirnika [stopnie]
	    if(counter_angle>=0)
	    	angle=angle_rotor_deg + (counter_angle * 360);
	    else
	    	angle=-angle_rotor_deg + (counter_angle * 360);

		// w³¹czenie/wy³¹cznie regulatora po³o¿enia (interfejs u¿ytkownika)
	    if(allow_angle[0]=='y')
	    {
	    	//mo¿liwoœæ zmniejszenia czêstotliwoœci obliczania pêtli regulacji po³o¿enia
		    // domyœlnie obliczenia s¹ wykonywane za ka¿dym uruchomieniem 
		    //funkcji obs³ugi przerwania ADC
	    	index_angle_loop++;
	    	if(index_angle_loop==1)
	    	{
	    		//uchyb po³o¿enia
	    		e_angle=set_angle-angle;	    		
	    		//zachowanie zmiennej z poprzedniego cyklu na potrzeby anti-windup
	    		angle_prev=pid_angle.state[2];
	    		// obliczenie wartoœci wyjœcia regulatora PID
	    		angle_speed=arm_pid_f32(&pid_angle, e_angle);
				//saturcja i anti-windup
	    	    if(angle_speed>=set_speed)
	    		{
	    		    pid_angle.state[2]=angle_prev;
	    		    angle_speed=set_speed;
	    	    }

	    		if(angle_speed<=(-set_speed))
	    		{
	    		    pid_angle.state[2]=angle_prev;
	    		    angle_speed=(-set_speed);
	    		}	    		
	    		set_sp= angle_speed;
	    	}
	        if(index_angle_loop==1)
	    		index_angle_loop=0;

	    }
	    else
	    {
	    	index_angle_loop=0;
	        set_sp=set_speed;
	    }

	    //mo¿liwoœæ zmniejszenia czêstotliwoœci obliczania pêtli regulacji prêdkoœci
		// domyœlnie obliczenia s¹ wykonywane za ka¿dym uruchomieniem 
		//funkcji obs³ugi przerwania ADC
	    index_speed_loop++;
	   	if(index_speed_loop==1)
	    {
	    	//uchyb prêdkoœci obrotowej
	        e_speed=set_sp-speed;
	        //zachowanie zmiennej z poprzedniego cyklu na potrzeby anti-windup
	    	iq_speed_prev=pid_iq_speed.state[2];
	    	// obliczenie wartoœci wyjœcia regulatora PID
	    	iq_speed=arm_pid_f32(&pid_iq_speed, e_speed);
	    	// saturacja i anty-wind-up
	    	if(iq_speed>=current_limit_max_iq)
	    	{
	    		pid_iq_speed.state[2]=iq_speed_prev;
	    		iq_speed=current_limit_max_iq;
	    	}
	    	if(iq_speed<=(-current_limit_max_iq))
	    	{
	    		pid_iq_speed.state[2]=iq_speed_prev;
	    		iq_speed=(-current_limit_max_iq);
	    	}
	   	}
	   	if(index_speed_loop==1)
	   		index_speed_loop=0;
	   		
		//obliczenie uchybu pr¹du Id
	    ed=set_d-Id;
	    //zachowanie zmiennej z poprzedniego cyklu na potrzeby anti-windup
	    Vd_prev=pid_d.state[2];
	    // obliczenie wartoœci wyjœcia regulatora PID
	    Vd=arm_pid_f32(&pid_d, ed);
	    // saturacja i anti-wind-up
	    if(Vd>=sv_Vdc_limit)
	    {
	    	pid_d.state[2]=Vd_prev;
	    	Vd=sv_Vdc_limit;
	    }

	    if(Vd<=(-sv_Vdc_limit))
	    {
	    	pid_d.state[2]=Vd_prev;
	        Vd=(-sv_Vdc_limit);
	    }

		//obliczenie uchybu pr¹du Iq
	    eq=iq_speed-Iq;
	    //zachowanie zmiennej z poprzedniego cyklu na potrzeby anti-windup
	    Vq_prev=pid_q.state[2];
	    // obliczenie wartoœci wyjœcia regulatora PID
	    Vq=arm_pid_f32(&pid_q, eq);
	    // saturacja i anti-wind-up
	    if(Vq>=sv_Vdc_limit)
	    {
	    	pid_q.state[2]=Vq_prev;
	    	Vq=sv_Vdc_limit;
	    }

	    if(Vq<=(-sv_Vdc_limit))
	    {
	    	pid_q.state[2]=Vq_prev;
	    	Vq=(-sv_Vdc_limit);
	    }

		//odwrotna transformacja park'a
	    arm_inv_park_f32(Vd, Vq, &Valpha, &Vbeta, pSinVal, pCosVal);
		//obliczenie modu³u wektora i k¹ta
	    AlphaBeta_To_Angle_Vref(Valpha, Vbeta, &angle_current_rad, &Vref);
	    //wyznaczenie w którym sektorze jest wektor pr¹du
	    Angle_To_Sector(angle_current_rad, &sector);
	    //wyznaczenie szerokoœci impulsów i przypisanie ich do rejestrów 
	    //kana³ów licznika, które steruj¹ bramkami przetwornika
	    SVPWM(sector, angle_current_rad , Vref, sv_T, sv_T_gate, &sv_S1, &sv_S2, &sv_S3);
	    TIM1->CCR1 = sv_S1;
	    TIM1->CCR2 = sv_S2;
	    TIM1->CCR3 = sv_S3;
	}
	//ponowne uruchomienie przetwornika ADC w tryb nas³uchu
	 HAL_ADCEx_InjectedStart_IT(&hadc1);
	 HAL_ADCEx_InjectedStart_IT(&hadc2);
}

// funkcja obs³ugi przerwania dla portu szeregowego
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
	//sprawdzenie czy w³aœciwy port szeregowy wywo³a³ zdarzenie obs³ugi przerwania
	if(huart->Instance==USART2)
	{
		//funkcja konfiguracyjna start_up() 
		//wywo³ywana tylko przy pierwszym uruchomieniu
		if(config==0)
		{
			config=1;
			start_up();
		}
		//pobranie ³añcucha znaków z portu szeregowego i konwersja do obiektu JSON
		cJSON * root = cJSON_Parse((char *)jstring);
		cJSON * set = cJSON_GetObjectItemCaseSensitive(root, "set");
		settings =  atoi(cJSON_GetStringValue(set));
		//sprawdzenie czy s¹ to dane konfiguracyjne 
		//czy komenda o starcie/zatrzymaniu pracy napêdu
		if(settings==0)
		{
			 cJSON * start_stop = cJSON_GetObjectItemCaseSensitive(root, "start_stop");
			 startstop =  atoi(cJSON_GetStringValue(start_stop));

			 if(startstop==1)
				 start1();
			 else
				 stop();
		 }
		 else
		 {
			 cJSON * speed = cJSON_GetObjectItemCaseSensitive(root, "speed");
			 set_speed =  atoi(cJSON_GetStringValue(speed));

			 cJSON * current = cJSON_GetObjectItemCaseSensitive(root, "current");
			 sscanf(cJSON_GetStringValue(current),"%f",&current_limit_max_iq);

			 cJSON * iq_Kp = cJSON_GetObjectItemCaseSensitive(root, "iq_Kp");
			 pid_q.Kp =  atoi(cJSON_GetStringValue(iq_Kp));

			 cJSON * iq_Ki = cJSON_GetObjectItemCaseSensitive(root, "iq_Ki");
			 pid_q.Ki =  atoi(cJSON_GetStringValue(iq_Ki));

			 cJSON * iq_Kd = cJSON_GetObjectItemCaseSensitive(root, "iq_Kd");
			 pid_q.Kd =  atoi(cJSON_GetStringValue(iq_Kd));

			 cJSON * id_Kp = cJSON_GetObjectItemCaseSensitive(root, "id_Kp");
			 pid_d.Kp =  atoi(cJSON_GetStringValue(id_Kp));

			 cJSON * id_Ki = cJSON_GetObjectItemCaseSensitive(root, "id_Ki");
			 pid_d.Ki =  atoi(cJSON_GetStringValue(id_Ki));

			 cJSON * id_Kd = cJSON_GetObjectItemCaseSensitive(root, "id_Kd");
			 pid_d.Kd =  atoi(cJSON_GetStringValue(id_Kd));

			 cJSON * speed_Kp = cJSON_GetObjectItemCaseSensitive(root, "speed_Kp");
			 pid_iq_speed.Kp =  atoi(cJSON_GetStringValue(speed_Kp));

			 cJSON * speed_Ki = cJSON_GetObjectItemCaseSensitive(root, "speed_Ki");
			 pid_iq_speed.Ki =  atoi(cJSON_GetStringValue(speed_Ki));

			 cJSON * speed_Kd = cJSON_GetObjectItemCaseSensitive(root, "speed_Kd");
			 pid_iq_speed.Kd =  atoi(cJSON_GetStringValue(speed_Kd));

			 cJSON * a_set = cJSON_GetObjectItemCaseSensitive(root, "a_set");
			 sprintf(allow_angle, "%s",(char *)(cJSON_GetStringValue(a_set)));

			 cJSON * angle = cJSON_GetObjectItemCaseSensitive(root, "angle");
			 set_angle =  atoi(cJSON_GetStringValue(angle));


			 cJSON * a_Kp = cJSON_GetObjectItemCaseSensitive(root, "a_Kp");
			 pid_angle.Kp =  atoi(cJSON_GetStringValue(a_Kp));

			 cJSON * a_Ki = cJSON_GetObjectItemCaseSensitive(root, "a_Ki");
			 pid_angle.Ki =  atoi(cJSON_GetStringValue(a_Ki));

			 cJSON * a_Kd = cJSON_GetObjectItemCaseSensitive(root, "a_Kd");
			 pid_angle.Kd =  atoi(cJSON_GetStringValue(a_Kd));
			 //usuniêcie obiektu JSON
			 cJSON_Delete(root);
			 //inicjalizacja struktur regulatorów PID nowymi parametrami
			 arm_pid_init_f32(&pid_d, 1);
			 arm_pid_init_f32(&pid_q, 1);
			 arm_pid_init_f32(&pid_iq_speed, 1);
			 arm_pid_init_f32(&pid_angle, 1);
		 }
		//ponowne uruchomienie nas³uchiwania portu szeregowego
		HAL_UART_Receive_IT(&huart2, jstring ,size_uart_tab);
	}
}
\end{lstlisting}



\subsection{Implementacja uk³adu regulacji}
\label{chapter:OPAMP}

W zestawie rozwojowym B-G431-ESC zosta³ zaimplementowany uk³ad regulacji pr¹du, prêdkoœci i po³o¿enia dla napêdu z silnikiem BLDC przy wykorzystaniu metod FOC i SVPWM.
 
Do mierzenia pr¹dów fazowych zosta³y wykorzystane wbudowane, dedykowane uk³ady.  Mierzony jest spadek napiêcia na rezystorach umieszczonych miêdzy doln¹ grup¹ tranzystorów mocy a mas¹. Na rysunku  \ref{fig:19} przedstawiono sposób pomiaru. W wyniku bardzo ma³ej rezystancji wynosz¹cej 0.03 $\Omega$  sygna³ jest wzmacniany przez wzmacniacz operacyjny i za pomoc¹ przetwornika analogowo-cyfrowego uzyskiwane aktualne wartoœci pr¹dów - rysunek \ref{fig:20}.

 \begin{figure}[H]
\centering
\includegraphics[width=8cm]{current_sense.png}   
\caption{Pomiar pr¹du \cite{stspin32}}
\label{fig:19}
\end{figure} 

 \begin{figure}[H]
\centering
\includegraphics[width=8cm]{opamp.png}   
\caption{Wzmacnianie mierzonego sygna³u  \cite{stspin32}}
\label{fig:20}
\end{figure} 


\label{chapter:OPAMP}

Pomiar prêdkoœci  odbywa siê za pomoc¹ enkodera. Licznik skonfigurowany w trybie Mode Reset resetuje siê w momencie podania stanu wysokiego na jeden z kana³ów, do którego pod³¹czony jest enkoder. Znaj¹c czêstotliwoœæ  zliczania i okres miêdzy wyst¹pieniem dwóch stanów wysokich mo¿na w ³atwy sposób obliczyæ aktualn¹ prêdkoœæ.

Pomiar po³o¿enia wirnika równie¿ odbywa siê przy pomocy enkodera. Licznik w konfiguracji Encoder Mode zlicza wykryte zbocza z dwóch kana³ów, do których pod³¹czone s¹ dwa sygna³y z czujnika ruchu przesuniête w fazie. W zale¿noœci od kierunku obrotu licznik jest inkrementowany lub dekrementowany. Po zliczeniu iloœci impulsów równej rozdzielczoœci enkodera licznik zlicza od zera.

Biblioteka CMSIS-DSP udostêpnia szereg funkcji dla obliczeñ transformat, regulatorów PID oraz funkcji trygonometrycznych. Funkcja obliczaj¹ca wartoœæ sygna³u wyjœciowego regulatora PID ma postaæ \cite{cmsis}:
\\

 \textit{float32\_t   arm\_pid\_f32 (arm\_pid\_instance\_f32 *S, float32\_t in)}
\\
\\
gdzie:\\
float32\_t in – uchyb\\
arm\_pid\_instance\_f32 *S -  struktura [A0, A1, A2, Kp, Ki, Kd, state[3]] opisana wyra¿eniem \ref{egn:22}:\\

\begin{equation} \label{egn:22}
\left\{ \begin{array}{ll}
y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]\\
   A0 = Kp + Ki + Kd\\
   A1 = (-Kp ) - (2 * Kd )\\
   A2 = Kd\\
\end{array} \right. 
\end{equation} 

\noindent Kp- wzmocnienie, Ki- sta³a ca³kowania, Kd- sta³a ró¿niczkowania
\vspace{0.4cm}

\noindent Rysunek poni¿ej reprezentuje schemat blokowy regulatora PID biblioteki CMSIS-DSP.

 \begin{figure}[H]
\centering
\includegraphics[width=8cm]{pid.png}   
\caption{Schemat regulatora PID biblioteki CMSIS-DSP \cite{cmsis}}
\label{fig:21}
\end{figure} 

Modulacja wektorowa SVPWM sk³ada siê z funkcji, które na podstawie zadanego wektora referencyjnego wyznacza trzy sygna³y  PWM oraz licznika skonfigurowanego w trybie PWM Center Mode z trzema kana³ami do wygenerowania sygna³ów PWM dla trzech par tranzystorów przekszta³tnika energoelektronicznego.  Dodatkowo czwarty kana³ przeznaczony jest do okreœlenia momentu uruchomienia przetwornika ADC i przypada on w po³owie okresu PWM, gdzie wszystkie tranzystory grupy dolnej s¹ w³¹czone a grupy górnej wy³¹czone. Na rysunku \ref{fig:22} przedstawiono synchronizacje wyzwalania przetwornika ADC z sygna³ami PWM.

 \begin{figure}[H]
\centering
\includegraphics[width=12cm]{synchronizacja.png}   
\caption{Synchronizacja sygan³u PWM z wyzwalaniem przerwania od przetwornika ADC}
\label{fig:22}
\end{figure} 
\vspace{0.4cm}

W funkcji obsu³gi przerwania od zdarzenia przetwornika ADC obliczane s¹ transformaty, funkcje regulatorów PID, transformaty odwrotne i funkcje modulacji wektorowej. W wyniku tych operacji, za pomoc¹ licznika z kana³ami steruj¹cymi bramkami tranzystorów przekszta³tnika, zostaj¹ wygenerowane trzy sygna³y PWM.


Do regulacji pr¹du, prêdkoœci i po³o¿enia zastosowano cztery regulatory PID po³¹czone ze sob¹ w sposób kaskadowy. Wynik regulatora zewnêtrznej pêtli wprowadzany jest na wejœcie regulatora pêtli wewnêtrznej. Schemat przedstawiono na rysunku \ref{fig:23}. Regulacja odbywa siê z czêstotliwoœci¹ wynosz¹c¹ 10kHz. 

 \begin{figure}[H]
\centering
\includegraphics[scale=0.7]{simulink.png}   
\caption{Model napêdu silnika BLDC}
\label{fig:23}
\end{figure} 
\vspace{0.4cm}

\subsection{Komunikacja}
Zestaw ewaluacyjny Nucleo F746ZG jest g³ównym wêz³em komunikacyjnym. £¹czy siê ze sterownikiem B-G431-ESC1 za pomoc¹ portu szeregowego UART o prêdkoœci transmisji 115200 bitów na sekunde. Za pomoc¹ tego portu wysy³ane s¹ wartoœci zadane pr¹du, prêdkoœci, po³o¿enia wirnika, nastawy regulatorów oraz ustawienia konfiguracyjne. B-G431-ESC1 generuje sygna³ PWM do synchronizacji pomiarów i obliczeñ z p³yt¹ Nucleo F746ZG. Rysunek \ref{fig:24} przedstawia    graficzny schemat uk³adu komunikacji. 
Nucleo F746ZG, wyposa¿ony w Ethernet i z³¹cze RJ45, ³¹czy siê z interfejsem u¿ytkownika zaimplementowanym na zdalnym komputerze za pomoc¹ przewodu sieciowego i routera. Informacje przekazywane s¹ za pomoc¹ protoko³u TCP/IP w postaci ³añcuchów znaków we formacie JSON (ang. JavaScript Object Notation). JSON jest formatem zapisu struktur danych przeznaczonym do wymiany informacji miêdzy aplikacjami. Dane zapisywane w notacji atrybut - wartoœæ charakteryzuj¹ siê prostot¹ i czytelnoœci¹. Za pomoc¹ interfejsu u¿ytkownika wysy³ane s¹ wartoœci zadane, nastawy regulatorów i ustawienia a odbierane bie¿¹ce wartoœci pr¹dów, prêdkoœci i po³o¿enia wirnika.

 \begin{figure}[H]
\centering
\includegraphics[scale=0.55]{komunikacja.png}   
\caption{Schemat uk³adu komunikacji}
\label{fig:24}
\end{figure} 
\vspace{0.4cm}




\subsection{Interfejs u¿ytkownika}

Interfejs u¿ytkownika zosta³ napisany w jêzyku Python przy pomocy oprogramowania Spyder w œrodowisku Anaconda. Aplikacja za pomoc¹ Ethernetu i protoko³u TCP/IP ³¹czy siê z p³yt¹ Nucleo F746ZG na której zaimplementowany jest serwer TCP. Informacje wysy³ane s¹ w postaci ³añcuchów znaków we formacie JSON. Aplikacja wysy³a do serwera zapytania cyklicznie co 20 ms. W odpowiedzi serwer zwraca informacje o bie¿¹cych wartoœciach pr¹dów fazowych, prêdkoœci i po³o¿eniu wirnika. Na rysunku \ref{fig:25} i \ref{fig:26}  przedstawiony jest interfejsu aplikacji. U¿ytkownik ma mo¿liwoœæ okreœlenia wartoœci zadanych pr¹du, prêdkoœci, po³o¿enia wirnika oraz nastaw dla regulatorów PID. Dodatkowo istnieje mo¿liwoœæ wy³¹czenia regulatora po³o¿enia i pozostawienia tylko aktywnego regulatora pr¹du i prêdkoœci. Przycisk \textit{Wyœlij ustawienia} powoduje dodanie do zapytania danych konfiguracyjnych i zaktualizowanie ustawieñ napêdu.\textit{Start, stop} uruchamia i zatrzymuje prace silnika. Przycisk \textit{Wyœwietl dane} przedstawia aktualne informacje z czujników w czêœci aplikacji oznaczonej jako \textit{POMIARY SILNIKA} oraz dodatkowo w osobnym oknie dialogowym przedstawia dane w postaci wykresów. Przycisk \textit{Kasuj} zatrzymuje i czyœci obszar wyœwietlanie wykresów.

 \begin{figure}[H]
\centering
\includegraphics[scale=0.65]{interfejs1.png}   
\caption{Interfejs u¿ytkownika}
\label{fig:25}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.55]{interfejs2.png}   
\caption{Interfejs u¿ytkownika}
\label{fig:26}
\end{figure} 
\vspace{0.4cm}





\section{Testowanie uk³adu napêdowego}
\label{chapter:3}
\subsection{Sprawdzenie poprawnoœci dzia³ania funkcji SVPWM}

Jednym z elementów uk³adu jest modulacja SVPWM. Sk³ada siê one ze zbioru funkcji, które zosta³y zaimplementowane i przetestowane w celu sprawdzenia poprawnoœci dzia³ania przed przyst¹pieniem do testowania wraz z regulatorami PID. Do funkcji zosta³y wprowadzone trzy sygna³y sinusoidalne o amplitudzie 1000, czêstotliwoœci 0.5 Hz, przesuniête w fazie o 120 stopni. W wyniku dzia³ania SVPWM generowany jest referencyjny wektor napiêciowy. Aby unikn¹æ zjawiska nadmodulacji i wynikaj¹cego z niej zniekszta³cenia sygna³u sinusoidalnego amplituda jest ograniczona do wartoœci $\sqrt{3}/2*Vdc$.  Wektor referencyjny za pomoc¹ transformat odwrotnych jest przekszta³cany w trzy przebiegi pokazane na rysunku \ref{fig:27}. W kolejnym etapie s¹ one porównywane ze sygna³em trójk¹tnym tworz¹c przebiegi prostok¹tne i wprowadzone na przetwornik energoelektroniczny. Do podgl¹du przebiegów zosta³o wykorzystane oprogramowanie STMStudio, które umo¿liwia graficzne wyœwietlenie stanu zmiennych programu w czasie rzeczywistym.  

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{svpwm_wykres.png}   
\caption{Przebiegi generowanych sygna³ów za pomoc¹ SVPWM na podstawie trzech wejœciowych sygna³ów sinusoidalnych}
\label{fig:27}
\end{figure} 
\vspace{0.4cm}

\subsection{Testowanie uk³adu regulacji}
Uk³ad zosta³ przetestowany dla nastaw regulatorów dobranych doœwiadczalnie i opisanych na rysunku \ref{fig:28}. Pomiary zosta³y wykonane za pomoc¹ oscyloskopu UNI-T UTD2102CEX i oprogramowania STMStudio do podgl¹du zmiennych programu w czasie rzeczywistym.

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{nastawy.png}   
\caption{Nastawy regulatorów PID}
\label{fig:28}
\end{figure} 
\vspace{0.4cm}

\subsubsection{Regulacja pr¹du}
\label{chapter:current}

W celu sprawdzenia poprawnoœci dzia³ania regulatorów wykonano pomiary dla trzech wartoœci amplitud sk³adowej pr¹du Iq: 0.3A, 0.5A, 1A dla przypadku gdzie wirnik nie zosta³ obci¹¿ony i dla przypadku dzia³ania zewnêtrznego momentu oporowego. Wartoœæ zadana prêdkoœci obrotowej wynosi 2500 obr/min. Przebiegi przedstawione s¹ rysunkach od \ref{fig:29} do \ref{fig:41}. Aby dokonaæ pomiaru pr¹du przy pomocy oscyloskopu do wyprowadzeñ uzwojeñ silnika zosta³y pod³¹czone rezystory o wartoœci 1 $\Omega$  dziêki czemu spadek napiêcia o wartoœci 1V odpowiada pr¹dowi o wartoœci 1A. 

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{03Abez.pdf}   
\caption{Przebieg pr¹du dla wartoœci zadanej amplitudy 0.3A bez obci¹¿enia zewnêtrznym momentem oporowym}
\label{fig:29}
\end{figure} 
\vspace{0.4cm}



 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{03Az.pdf}   
\caption{Przebieg pr¹du dla wartoœci zadanej amplitudy 0.3A z obci¹¿eniem zewnêtrznym}
\label{fig:30}
\end{figure} 
\vspace{0.4cm}

\textbf{ \begin{figure}[H]
\centering
\includegraphics[scale=0.32]{speed03A.png}   
\caption{Przebieg prêdkoœci obrotowej dla wartoœci zadanej 2500 obr/min i pr¹du 0.3A}
\label{fig:31}
\end{figure} 
\vspace{0.4cm}}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{05Abez.pdf}   
\caption{Przebieg pr¹du dla wartoœci zadanej amplitudy 0.5A bez obci¹¿enia zewnêtrznym momentem oporowym}
\label{fig:32}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{05Az.pdf}   
\caption{Przebieg pr¹du dla wartoœci zadanej amplitudy 0.5A z obci¹¿eniem zewnêtrznym}
\label{fig:33}
\end{figure} 
\vspace{0.4cm}

\textbf{ \begin{figure}[H]
\centering
\includegraphics[scale=0.45]{speed05A.png}   
\caption{Przebieg prêdkoœci obrotowej dla wartoœci zadanej 2500 obr/min i pr¹du 0.5A}
\label{fig:34}
\end{figure} 
\vspace{0.4cm}}


 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{1Abez.pdf}   
\caption{Przebieg pr¹du dla wartoœci zadanej amplitudy 1A bez obci¹¿enia zewnêtrznym momentem oporowym}
\label{fig:35}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{1Az.pdf}   
\caption{Przebieg pr¹du dla wartoœci zadanej amplitudy 1A z obci¹¿eniem zewnêtrznym}
\label{fig:36}
\end{figure} 
\vspace{0.4cm}

\textbf{ \begin{figure}[H]
\centering
\includegraphics[scale=0.38]{speed1A.png}   
\caption{Przebieg prêdkoœci obrotowej dla wartoœci zadanej 2500 obr/min i pr¹du 1A}
\label{fig:37}
\end{figure} 
\vspace{0.4cm}}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.45]{idiq1Abez.png}   
\caption{Przebieg sk³adowej Id, Iq dla wartoœci zadanej amplitudy pr¹du 1A bez obci¹¿enia zewnêtrznym momentem oporowym}
\label{fig:38}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.45]{idiq1A.png}   
\caption{Przebieg sk³adowej Id, Iq dla wartoœci zadanej amplitudy pr¹du 1A
z obci¹¿eniem zewnêtrznym momentem oporowym}
\label{fig:49}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.38]{alpha_beta.png}   
\caption{Hodograf pr¹du w uk³adzie wspó³rzêdnych alfa, beta dla wartoœci zadanej 1A}
\label{fig:39}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{napiecie_fazowe.pdf}   
\caption{Przebieg napiêcia fazowego}
\label{fig:40}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.6]{napiecie_miedzyfazowe.pdf}   
\caption{Przebieg napiêcia miêdzyfazowego}
\label{fig:41}
\end{figure} 
\vspace{0.4cm}



Z pomiarów wynika, ¿e regulacja pr¹du przy ustalonej prêdkoœci obrotowej i przy braku obci¹¿enia zewnêtrznym momentem oporowym, pr¹d ma przebieg zniekszta³cony i nieprzypominaj¹cy sinusoidy. Z wykresu sk³adowych pr¹du Iq i  strumienia magnetycznego Id, pokazanego na rysunku \ref{fig:38} widaæ, ¿e przebieg s¹ przemienne, co oznacza ¿e nie jest utrzymywany sta³y k¹t miêdzy polem magnetycznym wirnika i stojana. Moment elektromagnetyczny jest iloczynem strumienia magnetycznego, pr¹du i kosinusa k¹ta miêdzy polem magnetycznym stojana i wektorem si³y przeciwelektromotorycznej. Przy ustalonej prêdkoœci obrotowej i braku obci¹¿enia generowany jest niski moment napêdowy, który nie jest w stanie utrzymaæ  k¹ta 90 stopni miêdzy polami magnetycznymi. Uk³ad regulacji mimo wszystko próbuje uzyskaæ okreœlona wartoœæ zadan¹ generuj¹c oscylacje. 

Zwiêkszaj¹c moment oporowy przebieg pr¹du przyjmuje kszta³t sinusoidy o amplitudzie wartoœci zadanej. K¹t miêdzy polem magnetycznym wirnika i stojana ustala siê na poziome bliskim 90 stopni. W takim przypadku moment elektrodynamiczny jest równy iloczynowi pr¹du Iq i strumienia magnetycznego. Regulator prêdkoœci steruje pr¹dem Iq aby utrzymaæ prêdkoœæ obrotowa niezale¿nie od momentu oporowego. Wartoœæ zadana pr¹du Iq ustala maksymalny moment przy którym nie ma spadku prêdkoœci obrotowej.

Z przebiegów prêdkoœci obrotowej dla wartoœci zadanej 2500 obr/min dla nastaw
wartoœci pr¹du 0.3A, 0.5A, 1A, które zosta³y przedstawione na rysunkach \ref{fig:31}, \ref{fig:34} i \ref{fig:37} wynika, ¿e wartoœæ zadana pr¹du Iq bezpoœrednio wp³ywa na moment obrotowy i dynamikê uk³adu. Wraz ze wzrostem wartoœci pr¹du Iq wzrasta przyspieszenie silnika. Czas potrzebny do osi¹gniêcia 
ustalonej prêdkoœci zadanej 2500 obr/min wynosi kolejno: 
\begin{itemize}
\item 0.3 A - 0.5 sekundy,
\item 0.5 A - 0.22 sekundy,
\item 1 A - 0.09 sekundy.
\end{itemize} 


\subsubsection{Regulacja prêdkoœci obrotowej}
\label{chapter:speed}
Pomiary przebiegów prêdkoœci obrotowej zosta³y dokonane dla prêdkoœci obrotowych
3500,1500,500,200 obr/min przy amplitudzie pr¹du ograniczonej do 0.8A.
Przebiegi przedstawione na rysunkach \ref{fig:42}, \ref{fig:43}, \ref{fig:44} i \ref{fig:45}.

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{speed3500_1A}   
\caption{Przebieg prêdkoœci obrotowej o wartoœci zadanej 3500 obr/min}
\label{fig:42}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{speed1500_1A}   
\caption{Przebieg prêdkoœci obrotowej o wartoœci zadanej 1500 obr/min}
\label{fig:43}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{speed500_1A}   
\caption{Przebieg prêdkoœci obrotowej o wartoœci zadanej 500 obr/min}
\label{fig:44}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{speed200_1A}   
\caption{Przebieg prêdkoœci obrotowej o wartoœci zadanej 200 obr/min}
\label{fig:45}
\end{figure} 
\vspace{0.4cm}

Z pomiarów wynika, ¿e przy zastosowaniu uk³adu napêdowego ze sterowaniem wektorowym dla silnika trójfazowego uzyskujemy p³ynn¹ regulacjê prêdkoœci 
obrotowej w ca³ym zakresie. 



\subsubsection{Regulacja po³o¿enia wirnika}

W celu sprawdzenia jakoœci dzia³ania regulatora po³o¿enia wa³u silnika pomiary wykonano dla wartoœci zadanych 2000,1000 i 200 stopni. Przebiegi przedstawione na rysunkach \ref{fig:46}, \ref{fig:47} i \ref{fig:48}. Rozdzielczoœæ przetwornika obrotowo-impulsowego wynosi 720 impulsów/obr.

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{angle2000.png}   
\caption{Przebieg po³o¿enia wa³u silnika dla wartoœci zadanej 2000 stopni}
\label{fig:46}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{angle1000.png}   
\caption{Przebieg po³o¿enia wa³u silnika dla wartoœci zadanej 1000 stopni}
\label{fig:47}
\end{figure} 
\vspace{0.4cm}

 \begin{figure}[H]
\centering
\includegraphics[scale=0.4]{angle200.png}   
\caption{Przebieg po³o¿enia wa³u silnika dla wartoœci zadanej 200 stopni}
\label{fig:48}
\end{figure} 
\vspace{0.4cm}

Podczas monta¿u nie uda³o siê osi¹gn¹æ dok³adnej liniowoœci wa³u silnika i enkodera.
Z tego powodu wykorzystano sprzêg³o sprê¿ynowe, które powoduje, ¿e silnik jest obci¹¿ony dodatkowym momentem oporowym o niesta³ej wartoœci w zakresie jednego obrotu. Zjawisko to 
wp³ywa oscylacje po³o¿enia wirnika wzglêdem wartoœci zadanej. 


\section{Podsumowanie}

Do sprzêtowej konfiguracji napêdu wykorzystano zestaw rozwojowy
STM32 B-G431-ESC1 wyposa¿ony w rdzeñ ARM Cortex G4, przetwornik energoelektroniczny i 
w obwody pomiaru pr¹du. Jest uk³adem dedykowanym do budowania napêdów silnikowych.
Za komunikacjê miêdzy sterownikiem a interfejsem u¿ytkownika 
jest odpowiedzialny zestaw rozwojowy STM32 Nucleo F746ZG, który posiada wbudowany interfejs Ethernet za pomoc¹ którego ³¹czy siê z aplikacj¹ u¿ytkownika. Ze sterownikiem jest po³¹czony dziêki wykorzystaniu ³¹cza szeregowego UART. Interfejs u¿ytkownika
zosta³ zaprogramowany w jêzyku Python za pomoc¹ oprogramowania Spyder w œrodowisku Anaconda. Umo¿liwia wprowadzanie wartoœci zadanych pr¹du, prêdkoœci, po³o¿enia wirnika i
nastaw dla regulatorów PID. Wyœwietla aktualne parametry silnika w czasie rzeczywistym
w postaci tekstowej i wykresów. Uk³ad napêdowy zosta³ zaimplementowany na p³ycie STM32 B-G431-ESC1 w postaci sterowania wektorowego FOC i modulacji wektorowej SVPWM. Do stworzenia oprogramowania napêdu wykorzystano œrodowisko programistyczne STM32CubeIDE. Za pomoc¹ oscyloskopu UNI-T UTD2102CEX i aplikacji STMStudio, która umo¿liwia podgl¹d do zmiennych w czasie rzeczywistym, dokonano pomiarów przebiegów pr¹du, prêdkoœci obrotowej, po³o¿enia 
wirnika dla ró¿nych wartoœci zadanych przy okreœlonych nastawach regulatorów PID dobranych doœwiadczalnie.

Zgodnie z wynikami przebiegów przedstawionymi w podrozdziale \ref{chapter:current}, zaprojektowany napêd silnika BLDC reguluje wartoœci¹ pr¹du, który jest odpowiedzialny za moment elektromagnetyczny i dynamikê uk³adu.      
Regulacja odbywa siê w sposób prawid³owy, poniewa¿ dla przy³o¿onego momentu oporowego, przebieg pr¹du przyjmuje kszta³t sinusoidy o amplitudzie wartoœæ zadanej pr¹du Iq. Im wiêksza wartoœæ zadana pr¹du tym czas na rozpêdzenie siê wirnika do ustalonej prêdkoœci  obrotowej jest krótszy. Jednym z za³o¿eñ uk³adu napêdowego ze sterowaniem wektorowym stanowi mo¿liwoœæ p³ynnej regulacji prêdkoœci w ca³ym zakresie. Podrozdzia³ \ref{chapter:speed}, gdzie 
pokazano przebieg prêdkoœci obrotowej wirnika dla ró¿nych wartoœci zadanych, udowodnia
¿e cel ten zosta³ zrealizowany. Oscylacje na wykresach prêdkoœci i po³o¿enia wynikaj¹ z faktu, ¿e nie uda³o siê dok³adnie wycentrowaæ wirnika z wa³em enkodera. Z tego powodu wykorzystano sprzêg³o sprê¿ynowe, które powoduje, ¿e silnik jest obci¹¿ony dodatkowym momentem oporowym o niesta³ej wartoœci w zakresie jednego obrotu.

Du¿ym wyzwaniem okaza³o siê zaprojektowanie bezawaryjnego i efektywnego sposobu komunikacji miêdzy sterownikiem B-G431-ESC1, p³yt¹ Nucleo F746Zg i aplikacj¹ u¿ytkownika. Po wielu próbach i konfiguracjach najbardziej niezawodny okaza³ siê sposób, w którym sterownik
B-G431-ESC1 za pomoc¹ poru szeregowego otrzymuje tylko informacje o ustawieniach i parametrach napêdu, natomiast do zestawu Nucleo F746ZG  pod³¹czony zostaje przetwornik obrotowo-impulsowy i czujniki pr¹du. Dziêki temu rozwi¹zaniu uk³ady pracuj¹ w sposób bardziej niezale¿ny, mniej awaryjny i w maksymalny sposób ograniczone wykorzystanie 
portu szeregowego, który powodowa³ najwiêcej problemów z uzyskaniem synchronizacji 
miêdzy elementami uk³adu i aplikacj¹ u¿ytkownika.     

W przysz³oœci, do zaprojektowanego uk³adu napêdowego mo¿na dodaæ serwer WWW i napisaæ dodatkow¹ aplikacje dla urz¹dzeñ mobilnych. Interfejs u¿ytkownika, który jest napisany w jêzyku Python mo¿na rozszerzyæ o procedurê automatycznego sterowania napêdu silnika.





\addcontentsline{toc}{section}{Wykaz ilustracji}
\listoffigures

\bibliographystyle{plain} 
\bibliography{bibl} 

\end{document}






